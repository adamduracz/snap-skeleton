Snap Skeleton
=============

Skeleton for new Haskell/Snap RESTful Web Services. I've removed all unrelated
complexity such as Snaplets, Templating, Application state etc to make
it as simple as possible. However, I'm planning to include facilities
and examples for

- Parsing UTF8 encoded JSON request body into Haskell data values
- Generating a JSON response from Haskell data values
- Extracting values from RESTful paths like /users/jack
- Automated testing


What's wrong with `snap init`?
==============================

Well, you can do that too, but you'll get a lot of stuff that you ain't
gonna need for a typical RESTful Web Service. Don't you just hate to
look a ton of generated code that you don't understand?

Don't get me wrong here though: I really dig Snap. It's just `snap
init` I find unsuitable for my current needs.

Snap intro
==========

So, I wanted to see what's the minimal snap application like, and
couldn't find that anywhere on the Net. Luckily I had some spare time
and wrote it myself by removing all the stuff I couldn't grok from the
code generated by `snap init`. And, here it is:

~~~ .haskell
lol :: Snap()
lol = do 
    reqBody <- liftM (T.unpack . E.decodeUtf8) getRequestBody
    liftIO $ putStrLn $ "Received " ++ reqBody
    let reply = "You got lolld"
    writeLBS $ (E.encodeUtf8 . T.pack) $ reply  

main :: IO ()
main = quickHttpServe $ route [ ("/", lol) ] 
~~~ 

The main method starts Snap and routes the root url to a function named
`lol`. This function reads the request body (assuming it was a POST with
UTF-8 encoding),
then prints it to stdout and finally replies with the same string.

I think this is not bad: there's hardly any boilerplate there, except
maybe for the explicit UTF-8 decoding involved. You could drop the type
signratures too, if you don't find them useful.

Or, if you get to write a lot of actions that parse the request body as
a string and then produce some other string, you could extract this
boilerplate into a function like

~~~ .haskell
processPost :: (String -> String) -> Snap()
processPost f = do 
    reqBody <- liftM (T.unpack . E.decodeUtf8) getRequestBody
    writeLBS $ E.encodeUtf8 $ T.pack $ f $ reqBody
~~~

JSON
====

Using Text.JSON.Generic, working with JSON data is easy and fun. Like in
my extremely simple example "JsonEcho", you just define your data type
to match the JSON structure and call `encode`:

~~~ .haskell
{-# LANGUAGE DeriveDataTypeable #-}
import           Text.JSON.Generic

data Hello = Hello { message :: String } deriving (Data, Typeable, Show)

jsonMessage = encode $ Hello "Hello!"
~~~

This will generate a JSON string as in

~~~ .JSON
{ "message" : "Hello!" }
~~~

Parsing JSON is similarly easy. Just use the `encode` function.

Automatic testing
=================

TODO

Status
======

This stuff is under progress! Here's the backlog:

- Chapter on automatic testing
- Path variable extraction
- Pattern matching examples in tests
- Giter8 template for cloning the skeleton for _your_project_
- XML?
